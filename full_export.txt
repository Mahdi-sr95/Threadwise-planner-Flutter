================================================================================
PUBSPEC.YAML
================================================================================
name: threadwise_planner
description: "A new Flutter project."
publish_to: "none"

version: 1.0.0+1

environment:
  sdk: ^3.10.7

dependencies:
  flutter:
    sdk: flutter

  # State management + routing
  provider: ^6.1.2
  go_router: ^14.6.0

  # iOS-style icons
  cupertino_icons: ^1.0.8
  
  # HTTP client for API calls
  http: ^1.6.0
  
  # Local storage with SharedPreferences
  shared_preferences: ^2.2.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  flutter_lints: ^6.0.0

flutter:
  uses-material-design: true

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\app_shell.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

class AppShell extends StatelessWidget {
  final Widget child;
  const AppShell({super.key, required this.child});

  int _indexFromLocation(String location) {
    if (location.startsWith('/plan')) return 1;
    if (location.startsWith('/settings')) return 2;
    return 0; //courses
  }

  @override
  Widget build(BuildContext context) {
    final location = GoRouterState.of(context).uri.toString();
    final idx = _indexFromLocation(location);
    return Scaffold(
      body: child,
      bottomNavigationBar: NavigationBar(
        selectedIndex: idx,
        onDestinationSelected: (i) {
          switch (i) {
            case 0:
              context.go('/courses');
              break;
            case 1:
              context.go('/plan');
              break;
            case 2:
              context.go('/settings');
              break;
          }
        },
        destinations: const [
          NavigationDestination(icon: Icon(Icons.school), label: 'Courses'),
          NavigationDestination(icon: Icon(Icons.view_agenda), label: 'Plan'),
          NavigationDestination(icon: Icon(Icons.settings), label: 'Settings'),
        ],
      ),
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\main.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';

import 'app_shell.dart';
import 'screens/courses_screen.dart';
import 'screens/add_course_screen.dart';
import 'screens/plan_screen.dart';
import 'screens/settings_screen.dart';

import 'state/courses_provider.dart';
import 'state/plan_provider.dart';
import 'state/settings_provider.dart';

/// Main entry point - Initializes local storage and runs the app
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(const ThreadWiseApp());
}

class ThreadWiseApp extends StatefulWidget {
  const ThreadWiseApp({super.key});

  @override
  State<ThreadWiseApp> createState() => _ThreadWiseAppState();
}

class _ThreadWiseAppState extends State<ThreadWiseApp> {
  late final CoursesProvider _coursesProvider;
  bool _initialized = false;

  @override
  void initState() {
    super.initState();
    _initializeProviders();
  }

  /// Initialize all providers with local storage
  Future<void> _initializeProviders() async {
    _coursesProvider = CoursesProvider();
    await _coursesProvider.init();
    
    setState(() {
      _initialized = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!_initialized) {
      return const MaterialApp(
        home: Scaffold(
          body: Center(
            child: CircularProgressIndicator(),
          ),
        ),
      );
    }

    final router = GoRouter(
      initialLocation: '/courses',
      routes: [
        ShellRoute(
          builder: (context, state, child) => AppShell(child: child),
          routes: [
            GoRoute(
              path: '/courses',
              builder: (context, state) => const CoursesScreen(),
              routes: [
                GoRoute(
                  path: 'add',
                  builder: (context, state) => const AddCourseScreen(),
                ),
              ],
            ),
            GoRoute(
              path: '/plan',
              builder: (context, state) => const PlanScreen(),
            ),
            GoRoute(
              path: '/settings',
              builder: (context, state) => const SettingsScreen(),
            ),
          ],
        ),
      ],
    );

    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: _coursesProvider),
        ChangeNotifierProvider(create: (_) => PlanProvider()),
        ChangeNotifierProvider(create: (_) => SettingsProvider()),
      ],
      child: MaterialApp.router(
        title: 'ThreadWise Planner',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          useMaterial3: true,
          colorSchemeSeed: Colors.indigo,
        ),
        darkTheme: ThemeData(
          useMaterial3: true,
          brightness: Brightness.dark,
          colorSchemeSeed: Colors.indigo,
        ),
        routerConfig: router,
      ),
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\course.dart
================================================================================
import 'enums.dart';

/// Course model representing a subject with study requirements
/// Stored locally with custom serialization
class Course {
  final String id;
  final String name;
  final DateTime deadline;
  final Difficulty difficulty;
  final double studyHours;
  final DateTime createdAt;

  Course({
    String? id,
    required this.name,
    required this.deadline,
    required this.difficulty,
    required this.studyHours,
    DateTime? createdAt,
  })  : id = id ?? DateTime.now().millisecondsSinceEpoch.toString(),
        createdAt = createdAt ?? DateTime.now();

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'deadline': deadline.toIso8601String(),
      'difficulty': difficulty.name,
      'studyHours': studyHours,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  factory Course.fromJson(Map<String, dynamic> json) {
    return Course(
      id: json['id'] as String,
      name: json['name'] as String,
      deadline: DateTime.parse(json['deadline'] as String),
      difficulty: Difficulty.values.firstWhere(
        (e) => e.name == json['difficulty'],
      ),
      studyHours: (json['studyHours'] as num).toDouble(),
      createdAt: DateTime.parse(json['createdAt'] as String),
    );
  }

  Course copyWith({
    String? id,
    String? name,
    DateTime? deadline,
    Difficulty? difficulty,
    double? studyHours,
    DateTime? createdAt,
  }) {
    return Course(
      id: id ?? this.id,
      name: name ?? this.name,
      deadline: deadline ?? this.deadline,
      difficulty: difficulty ?? this.difficulty,
      studyHours: studyHours ?? this.studyHours,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  String toString() {
    return 'Course(id: $id, name: $name, deadline: $deadline, difficulty: ${difficulty.name}, studyHours: $studyHours)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Course && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\enums.dart
================================================================================
enum Difficulty {
  easy,
  medium,
  hard;

  String get displayName {
    switch (this) {
      case Difficulty.easy:
        return 'Easy';
      case Difficulty.medium:
        return 'Medium';
      case Difficulty.hard:
        return 'Hard';
    }
  }

  static Difficulty fromString(String value) {
    return Difficulty.values.firstWhere(
      (e) => e.name.toLowerCase() == value.toLowerCase(),
      orElse: () => Difficulty.medium,
    );
  }
}

enum Strategy {
  waterfall,
  sandwich,
  sequential,
  randomMix;

  // Display label for UI dropdowns and buttons
  String get label {
    switch (this) {
      case Strategy.waterfall:
        return 'Waterfall';
      case Strategy.sandwich:
        return 'Sandwich';
      case Strategy.sequential:
        return 'Sequential';
      case Strategy.randomMix:
        return 'Random Mix';
    }
  }

  String get displayName {
    switch (this) {
      case Strategy.waterfall:
        return 'Waterfall';
      case Strategy.sandwich:
        return 'Sandwich';
      case Strategy.sequential:
        return 'Sequential';
      case Strategy.randomMix:
        return 'Random Mix';
    }
  }

  // Detailed description explaining each strategy's behavior
  String get description {
    switch (this) {
      case Strategy.waterfall:
        return 'Start with hardest topics first, then progress to easier ones';
      case Strategy.sandwich:
        return 'Alternate between hard and easy topics for balanced learning';
      case Strategy.sequential:
        return 'Study topics in order by subject and deadline';
      case Strategy.randomMix:
        return 'Randomized study order for variety and reduced monotony';
    }
  }
}

enum InputStatus {
  unrelated,
  incomplete,
  complete;

  // User-facing validation message for each status
  String get message {
    switch (this) {
      case InputStatus.unrelated:
        return 'Your input does not appear to be related to course planning. Please provide course names, deadlines, and difficulty levels.';
      case InputStatus.incomplete:
        return 'Some required information is missing. Please provide course names, deadlines, and difficulty levels for all courses.';
      case InputStatus.complete:
        return 'Input validated successfully.';
    }
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\plan_request.dart
================================================================================
import 'enums.dart';

class PlanRequest {
  final String userInput;
  final Strategy strategy;
  final double maxHoursPerDay;
  final int breakMinutes;
  final DateTime? startDate;

  PlanRequest({
    required this.userInput,
    required this.strategy,
    this.maxHoursPerDay = 8.0,
    this.breakMinutes = 15,
    this.startDate,
  });

  Map<String, dynamic> toJson() {
    return {
      'userInput': userInput,
      'strategy': strategy.name,
      'maxHoursPerDay': maxHoursPerDay,
      'breakMinutes': breakMinutes,
      'startDate': startDate?.toIso8601String(),
    };
  }

  factory PlanRequest.fromJson(Map<String, dynamic> json) {
    return PlanRequest(
      userInput: json['userInput'] as String,
      strategy: Strategy.values.firstWhere(
        (e) => e.name == json['strategy'],
      ),
      maxHoursPerDay: (json['maxHoursPerDay'] as num).toDouble(),
      breakMinutes: json['breakMinutes'] as int,
      startDate: json['startDate'] != null
          ? DateTime.parse(json['startDate'] as String)
          : null,
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\plan_result.dart
================================================================================
import 'enums.dart';
import 'study_task.dart';

class PlanResult {
  final List<StudyTask> tasks;
  final InputStatus status;
  final String? errorMessage;
  final DateTime generatedAt;

  PlanResult({
    required this.tasks,
    required this.status,
    this.errorMessage,
    DateTime? generatedAt,
  }) : generatedAt = generatedAt ?? DateTime.now();

  bool get isSuccess => status == InputStatus.complete && errorMessage == null;

  Map<String, dynamic> toJson() {
    return {
      'tasks': tasks.map((t) => t.toJson()).toList(),
      'status': status.name,
      'errorMessage': errorMessage,
      'generatedAt': generatedAt.toIso8601String(),
    };
  }

  factory PlanResult.fromJson(Map<String, dynamic> json) {
    return PlanResult(
      tasks: (json['tasks'] as List)
          .map((t) => StudyTask.fromJson(t as Map<String, dynamic>))
          .toList(),
      status: InputStatus.values.firstWhere(
        (e) => e.name == json['status'],
      ),
      errorMessage: json['errorMessage'] as String?,
      generatedAt: DateTime.parse(json['generatedAt'] as String),
    );
  }

  factory PlanResult.error(String message, InputStatus status) {
    return PlanResult(
      tasks: [],
      status: status,
      errorMessage: message,
    );
  }

  factory PlanResult.success(List<StudyTask> tasks) {
    return PlanResult(
      tasks: tasks,
      status: InputStatus.complete,
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\saved_plan.dart
================================================================================
import 'study_task.dart';
import 'enums.dart';

/// Saved plan model with timestamp and strategy
/// Allows users to compare different planning strategies
class SavedPlan {
  final String id;
  final Strategy strategy;
  final List<StudyTask> tasks;
  final DateTime createdAt;
  final String? notes;

  SavedPlan({
    String? id,
    required this.strategy,
    required this.tasks,
    DateTime? createdAt,
    this.notes,
  })  : id = id ?? DateTime.now().millisecondsSinceEpoch.toString(),
        createdAt = createdAt ?? DateTime.now();

  /// Convert to JSON for storage
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'strategy': strategy.name,
      'tasks': tasks.map((t) => t.toJson()).toList(),
      'createdAt': createdAt.toIso8601String(),
      'notes': notes,
    };
  }

  /// Create from JSON
  factory SavedPlan.fromJson(Map<String, dynamic> json) {
    return SavedPlan(
      id: json['id'] as String,
      strategy: Strategy.values.firstWhere(
        (e) => e.name == json['strategy'],
      ),
      tasks: (json['tasks'] as List)
          .map((t) => StudyTask.fromJson(t as Map<String, dynamic>))
          .toList(),
      createdAt: DateTime.parse(json['createdAt'] as String),
      notes: json['notes'] as String?,
    );
  }

  /// Get formatted date for display
  String get formattedDate {
    final now = DateTime.now();
    final diff = now.difference(createdAt);
    
    if (diff.inMinutes < 60) {
      return '${diff.inMinutes}m ago';
    } else if (diff.inHours < 24) {
      return '${diff.inHours}h ago';
    } else if (diff.inDays < 7) {
      return '${diff.inDays}d ago';
    } else {
      return '${createdAt.day}/${createdAt.month}/${createdAt.year}';
    }
  }

  /// Get total study hours
  double get totalHours {
    return tasks.fold(0.0, (sum, task) => sum + task.durationHours);
  }

  SavedPlan copyWith({
    String? id,
    Strategy? strategy,
    List<StudyTask>? tasks,
    DateTime? createdAt,
    String? notes,
  }) {
    return SavedPlan(
      id: id ?? this.id,
      strategy: strategy ?? this.strategy,
      tasks: tasks ?? this.tasks,
      createdAt: createdAt ?? this.createdAt,
      notes: notes ?? this.notes,
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\models\study_task.dart
================================================================================
import 'enums.dart';

/// Study task model representing a scheduled study session
class StudyTask {
  final String subject;
  final String task;
  final DateTime dateTime;
  final double durationHours;
  final Difficulty difficulty;

  StudyTask({
    required this.subject,
    required this.task,
    required this.dateTime,
    required this.durationHours,
    required this.difficulty,
  });

  Map<String, dynamic> toJson() {
    return {
      'subject': subject,
      'task': task,
      'dateTime': dateTime.toIso8601String(),
      'durationHours': durationHours,
      'difficulty': difficulty.name,
    };
  }

  factory StudyTask.fromJson(Map<String, dynamic> json) {
    return StudyTask(
      subject: json['subject'] as String,
      task: json['task'] as String,
      dateTime: DateTime.parse(json['dateTime'] as String),
      durationHours: (json['durationHours'] as num).toDouble(),
      difficulty: Difficulty.values.firstWhere(
        (e) => e.name == json['difficulty'],
      ),
    );
  }

  String get formattedDuration {
    final hours = durationHours.floor();
    final minutes = ((durationHours - hours) * 60).round();
    if (hours == 0) {
      return '${minutes}m';
    } else if (minutes == 0) {
      return '${hours}h';
    } else {
      return '${hours}h ${minutes}m';
    }
  }

  String get formattedDateTime {
    return '${dateTime.day}/${dateTime.month} ${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  @override
  String toString() {
    return 'StudyTask(subject: $subject, task: $task, dateTime: $dateTime, duration: $formattedDuration)';
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\repositories\course_repository.dart
================================================================================
import '../models/course.dart';

abstract class CourseRepository {
  Future<void> saveCourse(Course course);
  
  Future<List<Course>> getAllCourses();
  
  Future<Course?> getCourseById(String id);
  
  Future<void> updateCourse(Course course);
  
  Future<void> deleteCourse(String id);
  
  Future<void> deleteAllCourses();
  
  Future<int> getCourseCount();
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\repositories\plan_repository.dart
================================================================================
import '../models/plan_result.dart';

abstract class PlanRepository {
  Future<void> savePlan(PlanResult plan, String name);
  
  Future<List<PlanResult>> getAllPlans();
  
  Future<PlanResult?> getLatestPlan();
  
  Future<void> deletePlan(String name);
  
  Future<void> deleteAllPlans();
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\repositories\shared_prefs_course_repository.dart
================================================================================
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/course.dart';
import 'course_repository.dart';

/// SharedPreferences implementation for Course storage
/// Uses JSON serialization for simple local data persistence
class SharedPrefsCourseRepository implements CourseRepository {
  static const String _key = 'courses';
  SharedPreferences? _prefs;

  /// Initialize SharedPreferences instance
  Future<void> init() async {
    _prefs = await SharedPreferences.getInstance();
  }

  SharedPreferences get _safePrefs {
    if (_prefs == null) {
      throw Exception('Repository not initialized. Call init() first.');
    }
    return _prefs!;
  }

  @override
  Future<void> saveCourse(Course course) async {
    final courses = await getAllCourses();
    final index = courses.indexWhere((c) => c.id == course.id);
    
    if (index >= 0) {
      courses[index] = course;
    } else {
      courses.add(course);
    }
    
    await _saveCourses(courses);
  }

  @override
  Future<List<Course>> getAllCourses() async {
    final jsonString = _safePrefs.getString(_key);
    if (jsonString == null) return [];
    
    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList
        .map((json) => Course.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  @override
  Future<Course?> getCourseById(String id) async {
    final courses = await getAllCourses();
    try {
      return courses.firstWhere((c) => c.id == id);
    } catch (e) {
      return null;
    }
  }

  @override
  Future<void> updateCourse(Course course) async {
    await saveCourse(course);
  }

  @override
  Future<void> deleteCourse(String id) async {
    final courses = await getAllCourses();
    courses.removeWhere((c) => c.id == id);
    await _saveCourses(courses);
  }

  @override
  Future<void> deleteAllCourses() async {
    await _safePrefs.remove(_key);
  }

  @override
  Future<int> getCourseCount() async {
    final courses = await getAllCourses();
    return courses.length;
  }

  /// Save courses list to SharedPreferences
  Future<void> _saveCourses(List<Course> courses) async {
    final jsonList = courses.map((c) => c.toJson()).toList();
    final jsonString = jsonEncode(jsonList);
    await _safePrefs.setString(_key, jsonString);
  }

  /// Close repository (no-op for SharedPreferences)
  Future<void> close() async {
    // SharedPreferences doesn't need explicit closing
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\screens\add_course_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';

import '../models/course.dart';
import '../models/enums.dart';
import '../state/courses_provider.dart';

/// Screen for adding a new course with name, deadline, difficulty, and study hours
class AddCourseScreen extends StatefulWidget {
  const AddCourseScreen({super.key});

  @override
  State<AddCourseScreen> createState() => _AddCourseScreenState();
}

class _AddCourseScreenState extends State<AddCourseScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameCtrl = TextEditingController();
  final _studyHoursCtrl = TextEditingController();

  DateTime? _deadline;
  Difficulty _difficulty = Difficulty.medium;

  @override
  void dispose() {
    _nameCtrl.dispose();
    _studyHoursCtrl.dispose();
    super.dispose();
  }

  /// Show date picker dialog for deadline selection
  Future<void> _pickDeadline() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      firstDate: DateTime(now.year, now.month, now.day),
      lastDate: DateTime(now.year + 5),
      initialDate: _deadline ?? now.add(const Duration(days: 7)),
    );

    if (picked != null) {
      setState(
        () => _deadline = DateTime(picked.year, picked.month, picked.day),
      );
    }
  }

  /// Format date as YYYY-MM-DD
  String _formatDate(DateTime d) {
    final mm = d.month.toString().padLeft(2, '0');
    final dd = d.day.toString().padLeft(2, '0');
    return '${d.year}-$mm-$dd';
  }

  /// Validate and save the course
  void _save() {
    final ok = _formKey.currentState?.validate() ?? false;
    if (!ok) return;

    if (_deadline == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a deadline')),
      );
      return;
    }

    final course = Course(
      name: _nameCtrl.text.trim(),
      deadline: _deadline!,
      difficulty: _difficulty,
      studyHours: double.parse(_studyHoursCtrl.text.trim()),
    );

    context.read<CoursesProvider>().addCourses(course);

    // Navigate back to courses list
    context.go('/courses');
  }

  @override
  Widget build(BuildContext context) {
    final deadlineText = _deadline == null
        ? 'Pick a date'
        : _formatDate(_deadline!);

    return Scaffold(
      appBar: AppBar(title: const Text('Add Course')),
      body: SafeArea(
        child: Form(
          key: _formKey,
          child: ListView(
            padding: const EdgeInsets.all(16),
            children: [
              Text(
                'Course details',
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 8),
              Text(
                'Enter the course info, then save.',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const SizedBox(height: 16),

              // Course name input field
              TextFormField(
                controller: _nameCtrl,
                decoration: const InputDecoration(
                  labelText: 'Course name',
                  hintText: 'e.g., Mobile Application Development',
                  border: OutlineInputBorder(),
                ),
                textInputAction: TextInputAction.next,
                validator: (v) {
                  if (v == null || v.trim().isEmpty) {
                    return 'Course name is required';
                  }
                  if (v.trim().length < 2) {
                    return 'Too short';
                  }
                  return null;
                },
              ),

              const SizedBox(height: 12),

              // Study hours input field
              TextFormField(
                controller: _studyHoursCtrl,
                decoration: const InputDecoration(
                  labelText: 'Study hours needed',
                  hintText: 'e.g., 15',
                  border: OutlineInputBorder(),
                  suffixText: 'hours',
                ),
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                inputFormatters: [
                  FilteringTextInputFormatter.allow(RegExp(r'^\d+\.?\d{0,1}')),
                ],
                textInputAction: TextInputAction.next,
                validator: (v) {
                  if (v == null || v.trim().isEmpty) {
                    return 'Study hours required';
                  }
                  final num = double.tryParse(v.trim());
                  if (num == null || num <= 0) {
                    return 'Enter a valid positive number';
                  }
                  if (num > 200) {
                    return 'Too many hours (max 200)';
                  }
                  return null;
                },
              ),

              const SizedBox(height: 12),

              // Deadline picker button
              InkWell(
                onTap: _pickDeadline,
                borderRadius: BorderRadius.circular(12),
                child: InputDecorator(
                  decoration: const InputDecoration(
                    labelText: 'Deadline',
                    border: OutlineInputBorder(),
                    suffixIcon: Icon(Icons.calendar_month),
                  ),
                  child: Text(deadlineText),
                ),
              ),
              const SizedBox(height: 12),

              // Difficulty dropdown selector
              DropdownButtonFormField<Difficulty>(
                initialValue: _difficulty,
                items: Difficulty.values
                    .map(
                      (d) => DropdownMenuItem(
                        value: d,
                        child: Text(
                          d.name[0].toUpperCase() + d.name.substring(1),
                        ),
                      ),
                    )
                    .toList(),
                onChanged: (v) =>
                    setState(() => _difficulty = v ?? Difficulty.medium),
                decoration: const InputDecoration(
                  labelText: 'Difficulty',
                  border: OutlineInputBorder(),
                ),
              ),

              const SizedBox(height: 20),

              // Save button
              SizedBox(
                width: double.infinity,
                child: FilledButton(
                  onPressed: _save,
                  child: const Text('Save'),
                ),
              ),
              const SizedBox(height: 8),

              // Cancel button
              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  onPressed: () => context.pop(),
                  child: const Text('Cancel'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\screens\courses_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';

import '../models/enums.dart';
import '../state/settings_provider.dart';
import '../state/courses_provider.dart';
import '../state/plan_provider.dart';

/// Main screen displaying user's courses and plan generation controls
/// Allows adding courses, selecting strategy, and triggering AI plan generation
class CoursesScreen extends StatelessWidget {
  const CoursesScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final coursesProv = context.watch<CoursesProvider>();
    final planProv = context.watch<PlanProvider>();
    final courses = coursesProv.courses;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Courses'),
        actions: [
          // Navigate to add course screen
          IconButton(
            onPressed: () => context.go('/courses/add'),
            icon: const Icon(Icons.add),
            tooltip: 'Add course',
          ),
        ],
      ),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            Text('Your courses', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 12),

            // Display empty state or list of courses
            if (courses.isEmpty)
              const Card(
                child: Padding(
                  padding: EdgeInsets.all(16),
                  child: Text('No courses yet. Tap + to add one.'),
                ),
              )
            else
              ...List.generate(courses.length, (i) {
                final c = courses[i];
                return Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: Card(
                    child: ListTile(
                      title: Text(c.name),
                      subtitle: Text(
                        'Deadline: ${_formatDate(c.deadline)} • ${c.difficulty.displayName} • ${c.studyHours}h',
                      ),
                      trailing: IconButton(
                        icon: const Icon(Icons.delete_outline),
                        onPressed: () => coursesProv.removeAt(i),
                      ),
                    ),
                  ),
                );
              }),

            const SizedBox(height: 16),

            // Strategy selection dropdown
            DropdownButtonFormField<Strategy>(
              value: planProv.strategy,
              items: Strategy.values
                  .map((s) => DropdownMenuItem(
                        value: s,
                        child: Text(s.label),
                      ))
                  .toList(),
              onChanged: (v) {
                if (v != null) planProv.setStrategy(v);
              },
              decoration: const InputDecoration(
                labelText: 'Study Strategy',
                border: OutlineInputBorder(),
                helperText: 'Choose how to organize your study sessions',
              ),
            ),

            const SizedBox(height: 8),

            // Display strategy description
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: Text(
                planProv.strategy.description,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
              ),
            ),

            const SizedBox(height: 12),

            // Generate plan button - disabled if no courses
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: courses.isEmpty
                    ? null
                    : () async {
                        // Retrieve settings and generate study plan
                        final settings =
                            context.read<SettingsProvider>().settings;
                        await planProv.generatePlan(courses, settings);
                        
                        // Navigate to plan screen after generation
                        if (context.mounted) context.go('/plan');
                      },
                icon: const Icon(Icons.auto_awesome),
                label: const Text('Generate Plan'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Format date as YYYY-MM-DD for display
  String _formatDate(DateTime date) {
    final year = date.year;
    final month = date.month.toString().padLeft(2, '0');
    final day = date.day.toString().padLeft(2, '0');
    return '$year-$month-$day';
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\screens\plan_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../models/enums.dart';
import '../state/courses_provider.dart';
import '../state/plan_provider.dart';

/// Plan screen with strategy selection and history
/// Displays generated study tasks grouped by date with save/load functionality
class PlanScreen extends StatelessWidget {
  const PlanScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Study Plan'),
        actions: [
          // History button
          Consumer<PlanProvider>(
            builder: (context, planProvider, _) {
              return IconButton(
                icon: Badge(
                  label: Text('${planProvider.planHistory.length}'),
                  isLabelVisible: planProvider.planHistory.isNotEmpty,
                  child: const Icon(Icons.history),
                ),
                tooltip: 'Plan History',
                onPressed: () => _showHistoryDialog(context),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // Strategy selector card
          Card(
            margin: const EdgeInsets.all(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Planning Strategy',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Consumer<PlanProvider>(
                    builder: (context, planProvider, _) {
                      return SegmentedButton<Strategy>(
                        segments: const [
                          ButtonSegment(
                            value: Strategy.waterfall,
                            label: Text('Waterfall'),
                            icon: Icon(Icons.layers),
                          ),
                          ButtonSegment(
                            value: Strategy.balanced,
                            label: Text('Balanced'),
                            icon: Icon(Icons.balance),
                          ),
                          ButtonSegment(
                            value: Strategy.cramming,
                            label: Text('Cramming'),
                            icon: Icon(Icons.speed),
                          ),
                        ],
                        selected: {planProvider.strategy},
                        onSelectionChanged: (Set<Strategy> newSelection) {
                          planProvider.setStrategy(newSelection.first);
                        },
                      );
                    },
                  ),
                  const SizedBox(height: 8),
                  Consumer<PlanProvider>(
                    builder: (context, planProvider, _) {
                      return Text(
                        _getStrategyDescription(planProvider.strategy),
                        style: Theme.of(context).textTheme.bodySmall,
                      );
                    },
                  ),
                ],
              ),
            ),
          ),

          // Generate button
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: [
                Expanded(
                  child: Consumer2<CoursesProvider, PlanProvider>(
                    builder: (context, coursesProvider, planProvider, _) {
                      return FilledButton.icon(
                        onPressed: planProvider.loading
                            ? null
                            : () async {
                                await planProvider.generatePlan(
                                  coursesProvider.courses,
                                );
                              },
                        icon: planProvider.loading
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : const Icon(Icons.auto_awesome),
                        label: Text(
                          planProvider.loading
                              ? 'Generating...'
                              : 'Generate Plan',
                        ),
                      );
                    },
                  ),
                ),
                const SizedBox(width: 8),
                // Save plan button
                Consumer<PlanProvider>(
                  builder: (context, planProvider, _) {
                    return IconButton.filledTonal(
                      onPressed: planProvider.tasks.isEmpty
                          ? null
                          : () => _savePlanDialog(context),
                      icon: const Icon(Icons.save),
                      tooltip: 'Save Plan',
                    );
                  },
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Tasks list
          Expanded(
            child: Consumer<PlanProvider>(
              builder: (context, planProvider, _) {
                if (planProvider.loading) {
                  return const Center(
                    child: CircularProgressIndicator(),
                  );
                }

                if (planProvider.error != null) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(
                          Icons.error_outline,
                          size: 64,
                          color: Colors.red,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Error: ${planProvider.error}',
                          style: const TextStyle(color: Colors.red),
                        ),
                      ],
                    ),
                  );
                }

                if (planProvider.tasks.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.calendar_today_outlined,
                          size: 64,
                          color: Colors.grey[400],
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'No study plan generated yet',
                          style: TextStyle(
                            fontSize: 16,
                            color: Colors.grey[600],
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Select a strategy and tap Generate Plan',
                          style: TextStyle(color: Colors.grey[500]),
                        ),
                      ],
                    ),
                  );
                }

                return _buildTasksList(planProvider.tasks);
              },
            ),
          ),
        ],
      ),
    );
  }

  /// Build tasks list grouped by date
  Widget _buildTasksList(List tasks) {
    final groupedTasks = <DateTime, List>{};
    
    for (final task in tasks) {
      final date = DateTime(
        task.dateTime.year,
        task.dateTime.month,
        task.dateTime.day,
      );
      groupedTasks.putIfAbsent(date, () => []).add(task);
    }

    final sortedDates = groupedTasks.keys.toList()..sort();

    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: sortedDates.length,
      itemBuilder: (context, index) {
        final date = sortedDates[index];
        final dayTasks = groupedTasks[date]!;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8),
              child: Text(
                _formatDate(date),
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            ...dayTasks.map((task) => Card(
                  child: ListTile(
                    leading: CircleAvatar(
                      backgroundColor: _getDifficultyColor(task.difficulty),
                      child: Text(
                        task.subject[0].toUpperCase(),
                        style: const TextStyle(color: Colors.white),
                      ),
                    ),
                    title: Text(task.subject),
                    subtitle: Text(task.task),
                    trailing: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        Text(
                          '${task.dateTime.hour}:${task.dateTime.minute.toString().padLeft(2, '0')}',
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                        Text(
                          task.formattedDuration,
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                  ),
                )),
            const SizedBox(height: 8),
          ],
        );
      },
    );
  }

  /// Show plan history dialog
  void _showHistoryDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        child: Container(
          constraints: const BoxConstraints(maxWidth: 600, maxHeight: 600),
          child: Column(
            children: [
              // Header
              Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    const Icon(Icons.history),
                    const SizedBox(width: 8),
                    const Text(
                      'Plan History',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.pop(context),
                    ),
                  ],
                ),
              ),
              const Divider(height: 1),
              
              // History list
              Expanded(
                child: Consumer<PlanProvider>(
                  builder: (context, planProvider, _) {
                    if (planProvider.planHistory.isEmpty) {
                      return const Center(
                        child: Text('No saved plans yet'),
                      );
                    }

                    return ListView.builder(
                      itemCount: planProvider.planHistory.length,
                      itemBuilder: (context, index) {
                        final plan = planProvider.planHistory[index];
                        return ListTile(
                          leading: Icon(_getStrategyIcon(plan.strategy)),
                          title: Text(
                            '${plan.strategy.name.toUpperCase()} - ${plan.tasks.length} tasks',
                          ),
                          subtitle: Text(
                            '${plan.formattedDate} • ${plan.totalHours.toStringAsFixed(1)}h total',
                          ),
                          trailing: IconButton(
                            icon: const Icon(Icons.delete),
                            onPressed: () async {
                              await planProvider.deletePlanFromHistory(plan.id);
                            },
                          ),
                          onTap: () {
                            planProvider.loadPlan(plan);
                            Navigator.pop(context);
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                content: Text('Plan loaded'),
                                duration: Duration(seconds: 2),
                              ),
                            );
                          },
                        );
                      },
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Show save plan dialog
  void _savePlanDialog(BuildContext context) {
    final notesController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Save Plan'),
        content: TextField(
          controller: notesController,
          decoration: const InputDecoration(
            labelText: 'Notes (optional)',
            hintText: 'e.g., Final exam preparation',
          ),
          maxLines: 2,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              final planProvider = context.read<PlanProvider>();
              await planProvider.saveCurrentPlan(
                notes: notesController.text.isNotEmpty
                    ? notesController.text
                    : null,
              );
              if (context.mounted) {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Plan saved to history'),
                    duration: Duration(seconds: 2),
                  ),
                );
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  String _getStrategyDescription(Strategy strategy) {
    switch (strategy) {
      case Strategy.waterfall:
        return 'Complete one course before starting the next';
      case Strategy.balanced:
        return 'Distribute study time evenly across all courses';
      case Strategy.cramming:
        return 'Focus on urgent deadlines first';
    }
  }

  IconData _getStrategyIcon(Strategy strategy) {
    switch (strategy) {
      case Strategy.waterfall:
        return Icons.layers;
      case Strategy.balanced:
        return Icons.balance;
      case Strategy.cramming:
        return Icons.speed;
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final tomorrow = today.add(const Duration(days: 1));

    if (date == today) {
      return 'Today';
    } else if (date == tomorrow) {
      return 'Tomorrow';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }

  Color _getDifficultyColor(Difficulty difficulty) {
    switch (difficulty) {
      case Difficulty.easy:
        return Colors.green;
      case Difficulty.medium:
        return Colors.orange;
      case Difficulty.hard:
        return Colors.red;
    }
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\screens\settings_screen.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../state/settings_provider.dart';

/// Settings screen for configuring study preferences
/// Allows customization of daily hours, break time, and weekend inclusion
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final prov = context.watch<SettingsProvider>();
    final s = prov.settings;

    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Daily study hours limit
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Daily Study Limit',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 8),
                    Text('Max hours per day: ${s.maxHoursPerDay.toStringAsFixed(0)}h'),
                    Slider(
                      value: s.maxHoursPerDay,
                      min: 1,
                      max: 12,
                      divisions: 11,
                      label: '${s.maxHoursPerDay.toInt()}h',
                      onChanged: (v) => prov.update(s.copyWith(maxHoursPerDay: v)),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 12),

            // Break time between study sessions
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Break Time',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 8),
                    Text('Break between sessions: ${s.breakMinutes} minutes'),
                    Slider(
                      value: s.breakMinutes.toDouble(),
                      min: 5,
                      max: 60,
                      divisions: 11,
                      label: '${s.breakMinutes}min',
                      onChanged: (v) => prov.update(s.copyWith(breakMinutes: v.toInt())),
                    ),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 12),

            // Weekend inclusion toggle
            Card(
              child: SwitchListTile(
                value: s.includeWeekends,
                onChanged: (v) => prov.update(s.copyWith(includeWeekends: v)),
                title: const Text('Include weekends'),
                subtitle: const Text('Schedule study sessions on Saturday and Sunday'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\services\llm_client.dart
================================================================================
import 'dart:convert';
import 'package:http/http.dart' as http;

/// Client for interacting with Hugging Face LLM API
/// Uses the new router.huggingface.co endpoint (2026)
/// Supports chat completion format with retry logic and error handling
class LLMClient {
  // New HuggingFace router endpoint (replaces api-inference.huggingface.co)
  static const String apiUrl = 'https://router.huggingface.co/v1/chat/completions';
  
  final String apiToken;
  final String model;

  LLMClient({
    required this.apiToken,
    this.model = 'meta-llama/Llama-3.2-3B-Instruct',
  });

  /// Send a prompt to the LLM and return the response
  /// Automatically retries on model loading (503) or network errors
  Future<String> sendPrompt(
    String prompt, {
    int maxTokens = 2500,
    String? systemPrompt,
  }) async {
    final messages = <Map<String, String>>[];
    
    if (systemPrompt != null) {
      messages.add({
        'role': 'system',
        'content': systemPrompt,
      });
    }

    messages.add({
      'role': 'user',
      'content': prompt,
    });

    int retries = 3;
    Duration waitTime = const Duration(seconds: 3);

    for (int i = 0; i < retries; i++) {
      try {
        final response = await http.post(
          Uri.parse(apiUrl),
          headers: {
            'Authorization': 'Bearer $apiToken',
            'Content-Type': 'application/json',
          },
          body: jsonEncode({
            'model': model, // Model is now in body, not URL
            'messages': messages,
            'max_tokens': maxTokens,
            'temperature': 0.7,
            'top_p': 0.9,
            'stream': false,
          }),
        ).timeout(const Duration(seconds: 60));

        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          if (data is Map && data.containsKey('choices')) {
            final choices = data['choices'] as List;
            if (choices.isNotEmpty) {
              final message = choices[0]['message'];
              return message['content']?.toString().trim() ?? '';
            }
          }
          return '';
        } else if (response.statusCode == 503) {
          // Model is loading, retry with exponential backoff
          if (i < retries - 1) {
            await Future.delayed(waitTime);
            waitTime = waitTime * 2;
            continue;
          }
          throw Exception('Model is still loading. Please try again later.');
        } else if (response.statusCode == 401) {
          throw Exception('Invalid API token. Check your HuggingFace token.');
        } else if (response.statusCode == 404 || response.statusCode == 410) {
          throw Exception('Model not found or endpoint not available.');
        } else {
          final errorBody = response.body;
          throw Exception('API Error ${response.statusCode}: $errorBody');
        }
      } catch (e) {
        if (e.toString().contains('SocketException') ||
            e.toString().contains('TimeoutException')) {
          if (i < retries - 1) {
            await Future.delayed(const Duration(seconds: 2));
            continue;
          }
          throw Exception('Network error. Check internet connection.');
        }
        rethrow;
      }
    }

    throw Exception('Failed after $retries attempts');
  }

  /// Test if the API connection works
  Future<bool> testConnection() async {
    try {
      final response = await sendPrompt(
        'Respond with just "OK"',
        systemPrompt: 'You are a helpful assistant.',
        maxTokens: 10,
      );
      return response.isNotEmpty;
    } catch (e) {
      return false;
    }
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\services\planning_service.dart
================================================================================
import '../models/plan_request.dart';
import '../models/plan_result.dart';
import '../models/enums.dart';

abstract class PlanningService {
  Future<PlanResult> generatePlan(PlanRequest request);
  
  Future<InputStatus> validateInput(String input);
  
  Future<bool> testConnection();
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\state\courses_provider.dart
================================================================================
import 'package:flutter/foundation.dart';
import '../models/course.dart';
import '../repositories/shared_prefs_course_repository.dart';

/// Provider for managing courses state with local persistence
/// Handles CRUD operations and notifies listeners on changes
class CoursesProvider extends ChangeNotifier {
  final SharedPrefsCourseRepository _repository = SharedPrefsCourseRepository();
  List<Course> _courses = [];
  bool _initialized = false;

  List<Course> get courses => List.unmodifiable(_courses);

  /// Initialize repository and load courses from storage
  Future<void> init() async {
    if (_initialized) return;
    
    await _repository.init();
    await _loadCourses();
    _initialized = true;
  }

  /// Load all courses from repository
  Future<void> _loadCourses() async {
    _courses = await _repository.getAllCourses();
    notifyListeners();
  }

  /// Add a new course and persist to storage
  Future<void> addCourses(Course course) async {
    await _repository.saveCourse(course);
    await _loadCourses();
  }

  /// Remove course at index and update storage
  Future<void> removeAt(int index) async {
    if (index < 0 || index >= _courses.length) return;
    
    final courseId = _courses[index].id;
    await _repository.deleteCourse(courseId);
    await _loadCourses();
  }

  /// Delete all courses from storage
  Future<void> clearAll() async {
    await _repository.deleteAllCourses();
    await _loadCourses();
  }

  @override
  void dispose() {
    _repository.close();
    super.dispose();
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\state\plan_provider.dart
================================================================================
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

import '../models/study_task.dart';
import '../models/saved_plan.dart';
import '../models/course.dart';
import '../models/enums.dart';
import '../services/planner_service.dart';

/// Provider for managing study plan generation and history
/// Handles different planning strategies and saves plan history
class PlanProvider extends ChangeNotifier {
  Strategy _strategy = Strategy.waterfall;
  List<StudyTask> _tasks = [];
  List<SavedPlan> _planHistory = [];
  bool _loading = false;
  String? _error;
  
  static const String _historyKey = 'plan_history';
  SharedPreferences? _prefs;

  Strategy get strategy => _strategy;
  List<StudyTask> get tasks => List.unmodifiable(_tasks);
  List<SavedPlan> get planHistory => List.unmodifiable(_planHistory);
  bool get loading => _loading;
  String? get error => _error;

  PlanProvider() {
    _initPrefs();
  }

  /// Initialize SharedPreferences and load history
  Future<void> _initPrefs() async {
    _prefs = await SharedPreferences.getInstance();
    await _loadHistory();
  }

  /// Change planning strategy
  void setStrategy(Strategy newStrategy) {
    if (_strategy != newStrategy) {
      _strategy = newStrategy;
      notifyListeners();
    }
  }

  /// Generate new study plan
  Future<void> generatePlan(List<Course> courses) async {
    if (courses.isEmpty) {
      _error = 'No courses available';
      notifyListeners();
      return;
    }

    _loading = true;
    _error = null;
    notifyListeners();

    try {
      await Future.delayed(const Duration(milliseconds: 500));
      _tasks = PlannerService.generatePlan(courses, _strategy);
      _error = null;
    } catch (e) {
      _error = e.toString();
      _tasks = [];
    } finally {
      _loading = false;
      notifyListeners();
    }
  }

  /// Save current plan to history
  Future<void> saveCurrentPlan({String? notes}) async {
    if (_tasks.isEmpty) return;

    final plan = SavedPlan(
      strategy: _strategy,
      tasks: List.from(_tasks),
      notes: notes,
    );

    _planHistory.insert(0, plan);
    
    // Keep only last 10 plans
    if (_planHistory.length > 10) {
      _planHistory = _planHistory.sublist(0, 10);
    }

    await _saveHistory();
    notifyListeners();
  }

  /// Load a saved plan
  void loadPlan(SavedPlan plan) {
    _strategy = plan.strategy;
    _tasks = List.from(plan.tasks);
    notifyListeners();
  }

  /// Delete a plan from history
  Future<void> deletePlanFromHistory(String planId) async {
    _planHistory.removeWhere((p) => p.id == planId);
    await _saveHistory();
    notifyListeners();
  }

  /// Clear all history
  Future<void> clearHistory() async {
    _planHistory.clear();
    await _saveHistory();
    notifyListeners();
  }

  /// Save history to SharedPreferences
  Future<void> _saveHistory() async {
    if (_prefs == null) return;
    
    final jsonList = _planHistory.map((p) => p.toJson()).toList();
    final jsonString = jsonEncode(jsonList);
    await _prefs!.setString(_historyKey, jsonString);
  }

  /// Load history from SharedPreferences
  Future<void> _loadHistory() async {
    if (_prefs == null) return;
    
    final jsonString = _prefs!.getString(_historyKey);
    if (jsonString == null) return;

    try {
      final List<dynamic> jsonList = jsonDecode(jsonString);
      _planHistory = jsonList
          .map((json) => SavedPlan.fromJson(json as Map<String, dynamic>))
          .toList();
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading plan history: $e');
    }
  }

  /// Clear current plan
  void clearPlan() {
    _tasks = [];
    _error = null;
    notifyListeners();
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\state\settings_provider.dart
================================================================================
import 'package:flutter/foundation.dart';

/// Model for user study preferences and constraints
/// Controls daily limits, break times, and weekend inclusion
class AppSettings {
  final double maxHoursPerDay;
  final int breakMinutes;
  final bool includeWeekends;

  const AppSettings({
    required this.maxHoursPerDay,
    required this.breakMinutes,
    required this.includeWeekends,
  });

  AppSettings copyWith({
    double? maxHoursPerDay,
    int? breakMinutes,
    bool? includeWeekends,
  }) {
    return AppSettings(
      maxHoursPerDay: maxHoursPerDay ?? this.maxHoursPerDay,
      breakMinutes: breakMinutes ?? this.breakMinutes,
      includeWeekends: includeWeekends ?? this.includeWeekends,
    );
  }
}

/// Provider managing user settings state
class SettingsProvider extends ChangeNotifier {
  AppSettings _settings = const AppSettings(
    maxHoursPerDay: 8,
    breakMinutes: 15,
    includeWeekends: true,
  );

  AppSettings get settings => _settings;

  void update(AppSettings s) {
    _settings = s;
    notifyListeners();
  }
}

================================================================================
FILE: C:\Users\Ost\Desktop\FlutterProjects\threadwise_planner\lib\utils\mock_data.dart
================================================================================
import '../models/course.dart';
import '../models/study_task.dart';
import '../models/enums.dart';

class MockData {
  static final List<Course> mockCourses = [
    Course(
      name: 'Mobile Application Development',
      deadline: DateTime(2026, 2, 15),
      difficulty: Difficulty.hard,
      studyHours: 20.0, // Hard course needs more hours
    ),
    Course(
      name: 'Database Systems',
      deadline: DateTime(2026, 2, 20),
      difficulty: Difficulty.medium,
      studyHours: 12.0,
    ),
    Course(
      name: 'Software Engineering',
      deadline: DateTime(2026, 2, 18),
      difficulty: Difficulty.medium,
      studyHours: 10.0,
    ),
    Course(
      name: 'Computer Networks',
      deadline: DateTime(2026, 2, 22),
      difficulty: Difficulty.easy,
      studyHours: 8.0,
    ),
  ];

  static final List<StudyTask> mockPlan = [
    StudyTask(
      subject: 'Mobile Application Development',
      task: 'Flutter basics and widgets',
      dateTime: DateTime(2026, 1, 21, 9, 0),
      durationHours: 2.5,
      difficulty: Difficulty.hard,
    ),
    StudyTask(
      subject: 'Database Systems',
      task: 'SQL queries and normalization',
      dateTime: DateTime(2026, 1, 21, 14, 0),
      durationHours: 2.0,
      difficulty: Difficulty.medium,
    ),
    StudyTask(
      subject: 'Mobile Application Development',
      task: 'State management with Provider',
      dateTime: DateTime(2026, 1, 22, 9, 0),
      durationHours: 3.0,
      difficulty: Difficulty.hard,
    ),
    StudyTask(
      subject: 'Software Engineering',
      task: 'Design patterns review',
      dateTime: DateTime(2026, 1, 22, 14, 30),
      durationHours: 1.5,
      difficulty: Difficulty.medium,
    ),
    StudyTask(
      subject: 'Computer Networks',
      task: 'OSI model and protocols',
      dateTime: DateTime(2026, 1, 23, 10, 0),
      durationHours: 1.5,
      difficulty: Difficulty.easy,
    ),
  ];
}

